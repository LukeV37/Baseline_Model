#include <vector>
#include <iostream>
#include <set>
#include <time.h>
#include <cstdlib>
#include <algorithm>

void preprocess(){
    // Declare pointer to the root file
    TFile *file = new TFile("../refine/refined_ttbar.root");

    // Declare pointer to the TTree
    TTree *tree = (TTree*)file->Get("Data");

    // Declare local vars and have branches point to these local vars
    int num_feat = 19;
    vector<float> *features = 0;              // Used to store training variables
    int j_label;                            // Pileup label for jet
    int t_label;                            // Pileup label for trk
    int t_ID;                               // Unique trk ID used for edges
    int j_ID;                               // Unique trk ID used for balancing
    int E_ID;                             // Event ID used for splitting test train
    tree->SetBranchAddress("features",&features);
    tree->SetBranchAddress("jet_label",&j_label);
    tree->SetBranchAddress("trk_label",&t_label);
    tree->SetBranchAddress("trk_ID",&t_ID);
    tree->SetBranchAddress("jet_ID",&j_ID);
    tree->SetBranchAddress("Event_ID",&E_ID);

    // Declare c++ vectors
    vector<vector<float> > feats;
    vector<float> trk_feat;
    vector<int> jet_label;
    vector<int> trk_label;
    vector<int> trk_ID;
    vector<int> jet_ID;
    vector<int> Event_ID;
    vector<int> isKept;
    vector<int> isTrain;
    vector<int> isTest;

    // Read entries and store in c++ vectors for easy indexing
    Long64_t nentries = tree->GetEntries();
    for (int i=0;i<nentries;i++){
        tree->GetEntry(i);
        jet_label.push_back(j_label);
        trk_label.push_back(t_label);
        trk_ID.push_back(t_ID);
        jet_ID.push_back(j_ID);
        Event_ID.push_back(E_ID);
        isKept.push_back(1);
        isTrain.push_back(0);
        isTest.push_back(0);
        //cout << "size" << features->size() << endl;
        float *dat = features->data(); // MUST be done for every tree entry
        trk_feat.clear();              // Make sure to clean up after each track
        for(int j=0;j<num_feat;j++){
            trk_feat.push_back(*dat);
        }
        feats.push_back(trk_feat);
    }
    // Now we are done reading data from root file and now we can use c++ vectors! :)

    // Balance Events by cutting subgraphs
    // loop through each event and store vertex labels of jets in that event
    // generate random number to see if background vertex is cut
    srand( time( 0 ) );         // Set the seed of srand() with the current time
    float threshold = 0.91;      // Threshold which defines rejection of background
    float rng = 0;              // A (psuedo)random number generated by rand() function
    set<int> s;                 // The set of all vertex labels in each event
    set<int> E;                 // The set of all event labels
    vector<int> labels;         // An iterable of all vertex labels in each event
    vector<int> cut_labels;     // A list of which verticies to cut

    // Before looping through Dataset, first determine the total number of Events
    for (int i=0;i<trk_label.size();i++){
        E.insert(Event_ID[i]);
    }
    int num_Events = E.size();
    
    int E_current_ID;           // Set the starting seed for event ID
    int E_start_idx=0;          // Used to save idx of when event starts
    int E_end_idx=0;            // Used to save idx of when event ends
    int num_trk;                // Used to save the number of tracks per event


    for(int i=0;i<num_Events;i++){
        num_trk=0;                              // Reset num_trk to zero at the beginning of each event
        E_start_idx = E_end_idx;                // At the beginning of the event pick up where the last event left off.
        E_current_ID = Event_ID[E_start_idx];   // Reset the current event ID after while loop breaks
        cut_labels.clear();                     // Reset the cut labels at the beginning of each event

        // Figure out how many tracks per event and the Event ending idx using a while loop
        while(E_current_ID == Event_ID[E_end_idx]){
            E_end_idx++;
            num_trk++;
        }
        // Insert all verticies from this event into a set
        for(int j=E_start_idx;j<E_end_idx;j++){
            s.insert(jet_label[j]);
        }
        labels.assign(s.begin(),s.end());       // Generate an iterable vector from the set of verticies
    
        // Iterate through labels and cut subgraphs in order to balance the dataset
        for (int k=0;k<labels.size();k++){
            if(labels[k] == -1) continue;
            rng = ((float) rand() / (float) RAND_MAX);  // Generate a (psuedo)random number between 0 and 1
            if (rng<threshold){
                cut_labels.push_back(labels[k]);
            }
        }

        // Loop through tracks in the event, check if jet_lable is an element of cut list, if so set isKept to zero.
        for(int j=E_start_idx;j<E_end_idx;j++){
            if (find(cut_labels.begin(), cut_labels.end(), jet_label[j]) != cut_labels.end() ){
                isKept[j] = 0;      // Vertex label is found in cut list and trk is discarded
            };
        }
    }

    // Now that the dataset has been balanced, we split into testing and training datasets
    float split = 0.75;
    vector<int> Events;
    vector<int> TrainEvents;
    Events.assign(E.begin(),E.end());
    int split_idx = int(Events.size() * split);
    for(int i=0;i<split_idx;i++){
        TrainEvents.push_back(Events[i]);
    }
    for(int i=0;i<trk_label.size();i++){
        if (find(TrainEvents.begin(), TrainEvents.end(), Event_ID[i]) != TrainEvents.end() ){
            isTrain[i] = 1;
        }
        else isTest[i] = 1;
    }

    // Now Write Required information back into root file
    TFile output("output.root","recreate");
    TTree *t2 = new TTree("Data", "Balanced and Split Dataset");
    TTree *t3 = new TTree("Train", "Balanced and Split Dataset for Training");
    TTree *t4 = new TTree("Test", "Balanced and Split Dataset for Testing");

    int Keep;
    int Train;
    int Test;

    t2->Branch("features", &features);
    t2->Branch("jet_label", &j_label);
    t2->Branch("trk_label", &t_label);
    t2->Branch("trk_ID", &t_ID);
    t2->Branch("jet_ID", &j_ID);
    t2->Branch("Event_ID", &E_ID);
    t2->Branch("isKept", &Keep);
    t2->Branch("isTrain", &Train);
    t2->Branch("isTest", &Test);

    t3->Branch("features", &features);
    t3->Branch("jet_label", &j_label);
    t3->Branch("trk_label", &t_label);
    t3->Branch("trk_ID", &t_ID);
    t3->Branch("jet_ID", &j_ID);
    t3->Branch("Event_ID", &E_ID);

    t4->Branch("features", &features);
    t4->Branch("jet_label", &j_label);
    t4->Branch("trk_label", &t_label);
    t4->Branch("trk_ID", &t_ID);
    t4->Branch("jet_ID", &j_ID);
    t4->Branch("Event_ID", &E_ID);
    
    for(int i=0;i<trk_label.size();i++){
        tree->GetEntry(i);
        if(trk_label[i]==-999) continue;
        if(trk_label[i]==0) t_label=1;
        else t_label=0;
        if(jet_label[i]!=-1) j_label=0;
        else j_label=1;
        Keep=isKept[i];
        Train=isTrain[i];
        Test=isTest[i];
        t2->Fill();
        if(Train==1&&Keep==1) t3->Fill();
        if(Test==1&&Keep==1) t4->Fill();
    }
    t2->Write();
    t3->Write();
    t4->Write();
    cout << "Train " << float(reduce(isTrain.begin(),isTrain.end())) / (float) isTrain.size() << endl;
    cout << "Test " << (float) reduce(isTest.begin(),isTest.end()) / (float) isTest.size() << endl;
    cout << "Kept " << (float) reduce(isKept.begin(),isKept.end()) / (float) isKept.size() << endl;
}

// TO-DO:
// -Then convert to zero based indices
// -Then create edges
// -Then write features and edges to root file
// -Then cout info into a text file
